require('dotenv').config();
const { Client, GatewayIntentBits, Collection, PermissionFlagsBits, ChannelType, REST, Routes } = require('discord.js');
const { commands, getChannelPrefix } = require('./commands');
const { processMessage } = require('./auto-moderation');
const Parser = require('rss-parser');
const cron = require('node-cron');

// Inicjalizacja klienta Discord
const client = new Client({
    intents: [
        GatewayIntentBits.Guilds,
        GatewayIntentBits.GuildVoiceStates,
        GatewayIntentBits.GuildMessages,
        GatewayIntentBits.GuildMessageReactions,
        GatewayIntentBits.MessageContent,
        GatewayIntentBits.GuildMembers // Dodane dla Welcome/Leave System
    ]
});

// Kolekcja komend
client.commands = new Collection();
commands.forEach(command => {
    client.commands.set(command.data.name, command);
});

// Przechowywanie informacji o utworzonych kana≈Çach
client.createdChannels = new Collection();
client.channelOwners = new Collection();

// Przechowywanie konfiguracji reaction roles
// Format: messageId -> { channelId, emoji, roleId }
client.reactionRoles = new Collection();

// Konfiguracja Welcome/Leave System
const WELCOME_CHANNEL_ID = '1412923730958487703'; // Kana≈Ç og√≥lny
const LOG_CHANNEL_ID = '1412925469338107945'; // Kana≈Ç moderacji
const VOICE_CATEGORY_ID = '1412920201724563629'; // Kategoria g≈Çosowa

// Konfiguracja RSS parser dla news√≥w Battlefield 6
const fs = require('fs');
const crypto = require('crypto');
const parser = new Parser();
const BF6_NEWS_CHANNEL_ID = '1412920468540883026';
const RSS_FEEDS = [
    'https://gameranx.com/tag/battlefield/feed/',
];

// Plik do przechowywania ju≈º wys≈Çanych news√≥w
const NEWS_STORAGE_FILE = './sent_news.json';

// Przechowywanie ostatnich news√≥w (aby uniknƒÖƒá duplikat√≥w)
client.lastNewsItems = new Set();

// Funkcja do ≈Çadowania ju≈º wys≈Çanych news√≥w z pliku
function loadSentNews() {
    try {
        if (fs.existsSync(NEWS_STORAGE_FILE)) {
            const data = fs.readFileSync(NEWS_STORAGE_FILE, 'utf8');
            const sentNews = JSON.parse(data);
            client.lastNewsItems = new Set(sentNews);
            console.log(`üìÇ Za≈Çadowano ${sentNews.length} ju≈º wys≈Çanych news√≥w`);
        }
    } catch (error) {
        console.error('‚ùå B≈ÇƒÖd podczas ≈Çadowania wys≈Çanych news√≥w:', error);
        client.lastNewsItems = new Set();
    }
}

// Funkcja do zapisywania ju≈º wys≈Çanych news√≥w do pliku
function saveSentNews() {
    try {
        const sentNewsArray = Array.from(client.lastNewsItems);
        fs.writeFileSync(NEWS_STORAGE_FILE, JSON.stringify(sentNewsArray, null, 2));
    } catch (error) {
        console.error('‚ùå B≈ÇƒÖd podczas zapisywania wys≈Çanych news√≥w:', error);
    }
}

// Funkcja do generowania unikalnego hash dla newsa
function generateNewsHash(item) {
    const content = `${item.title}${item.link}${item.pubDate || ''}`;
    return crypto.createHash('md5').update(content).digest('hex');
}

// Event: Bot gotowy
client.once('ready', async () => {
    console.log(`‚úÖ Bot zalogowany jako ${client.user.tag}`);
    console.log(`üîß Aktywny na ${client.guilds.cache.size} serwerach`);
    
    // Ustawienie statusu bota
    client.user.setActivity('Tworzenie kana≈Ç√≥w g≈Çosowych', { type: 'WATCHING' });
    
    // Czyszczenie pustych kana≈Ç√≥w g≈Çosowych przy starcie
    console.log('üßπ Czyszczenie pustych kana≈Ç√≥w g≈Çosowych...');
    await cleanupEmptyVoiceChannels();
    
    // ≈Åadowanie ju≈º wys≈Çanych news√≥w
    loadSentNews();
    
    // Rejestracja komend slash
    await registerSlashCommands();
    
    // Uruchomienie systemu news√≥w Battlefield 6
    console.log('üéÆ Uruchamianie systemu news√≥w Battlefield 6...');
    await checkBF6News(); // Pierwsze sprawdzenie
    startBF6NewsScheduler(); // Uruchomienie harmonogramu
});

// Funkcja czyszczenia pustych kana≈Ç√≥w g≈Çosowych przy starcie bota
async function cleanupEmptyVoiceChannels() {
    try {
        for (const guild of client.guilds.cache.values()) {
            const category = guild.channels.cache.get(VOICE_CATEGORY_ID);
            if (!category) {
                console.log(`‚ö†Ô∏è Nie znaleziono kategorii g≈Çosowej o ID: ${VOICE_CATEGORY_ID}`);
                continue;
            }
            
            const voiceChannels = category.children.cache.filter(channel => 
                channel.type === ChannelType.GuildVoice && 
                channel.members.size === 0 &&
                (client.channelOwners.has(channel.id) || channel.name.startsWith('[BF6]')) // Kana≈Çy utworzone przez bota lub z prefiksem [BF6]
            );
            
            let deletedCount = 0;
            for (const channel of voiceChannels.values()) {
                try {
                    const ownerId = client.channelOwners.get(channel.id);
                    await channel.delete('Czyszczenie pustych kana≈Ç√≥w przy starcie bota');
                    
                    // Usu≈Ñ z pamiƒôci bota (tylko je≈õli kana≈Ç by≈Ç w pamiƒôci)
                    if (ownerId) {
                        client.createdChannels.delete(ownerId);
                        client.channelOwners.delete(channel.id);
                    }
                    
                    deletedCount++;
                    console.log(`üóëÔ∏è Usuniƒôto pusty kana≈Ç: ${channel.name}`);
                } catch (error) {
                    console.error(`‚ùå B≈ÇƒÖd podczas usuwania kana≈Çu ${channel.name}:`, error);
                }
            }
            
            if (deletedCount > 0) {
                console.log(`‚úÖ Wyczyszczono ${deletedCount} pustych kana≈Ç√≥w g≈Çosowych`);
            } else {
                console.log(`‚úÖ Brak pustych kana≈Ç√≥w do wyczyszczenia`);
            }
        }
    } catch (error) {
        console.error('‚ùå B≈ÇƒÖd podczas czyszczenia pustych kana≈Ç√≥w:', error);
    }
}

// Event: Zmiana stanu kana≈Çu g≈Çosowego
client.on('voiceStateUpdate', async (oldState, newState) => {
    try {
        await handleVoiceStateUpdate(oldState, newState);
    } catch (error) {
        console.error('‚ùå B≈ÇƒÖd podczas obs≈Çugi zmiany stanu g≈Çosowego:', error);
    }
});

// Funkcja obs≈ÇugujƒÖca zmiany stanu kana≈Ç√≥w g≈Çosowych
async function handleVoiceStateUpdate(oldState, newState) {
    const triggerChannelId = process.env.TRIGGER_CHANNEL_ID;
    const voiceCategoryId = process.env.VOICE_CATEGORY_ID;
    
    // U≈ºytkownik do≈ÇƒÖczy≈Ç do kana≈Çu trigger
    if (newState.channelId === triggerChannelId && oldState.channelId !== triggerChannelId) {
        await createUserVoiceChannel(newState.member, newState.guild, voiceCategoryId);
    }
    
    // U≈ºytkownik opu≈õci≈Ç kana≈Ç - sprawd≈∫ czy kana≈Ç jest pusty i czy nale≈ºy go usunƒÖƒá
    if (oldState.channel && oldState.channel.id !== triggerChannelId) {
        await checkAndDeleteEmptyChannel(oldState.channel);
    }
}

// Funkcja tworzƒÖca nowy kana≈Ç g≈Çosowy dla u≈ºytkownika
async function createUserVoiceChannel(member, guild, categoryId) {
    try {
        const prefix = process.env.CHANNEL_PREFIX || '[BF6]';
        const channelName = `${prefix} ${member.displayName}`;
        
        // Sprawd≈∫ czy u≈ºytkownik ju≈º ma sw√≥j kana≈Ç
        const existingChannel = client.createdChannels.get(member.id);
        if (existingChannel && guild.channels.cache.has(existingChannel)) {
            // Przenie≈õ u≈ºytkownika do istniejƒÖcego kana≈Çu
            await member.voice.setChannel(existingChannel);
            return;
        }
        
        // Znajd≈∫ wymagane role
        const zweryfikowanyRole = guild.roles.cache.find(role => role.name === 'Zweryfikowany');
        const moderatorRole = guild.roles.cache.find(role => role.name === 'Moderator');
        const adminRole = guild.roles.cache.find(role => role.name === 'Admin');
        const bf6Role = guild.roles.cache.find(role => role.name === 'Battlefield 6 Polska');
        
        // Przygotuj uprawnienia dla kana≈Çu
        const permissionOverwrites = [
            {
                id: guild.id, // @everyone - brak dostƒôpu
                deny: [PermissionFlagsBits.ViewChannel, PermissionFlagsBits.Connect],
            },
            {
                id: member.id, // W≈Ça≈õciciel kana≈Çu
                allow: [
                    PermissionFlagsBits.ViewChannel,
                    PermissionFlagsBits.Connect,
                    PermissionFlagsBits.ManageChannels, // Pozwala na zmianƒô nazwy i limitu
                    PermissionFlagsBits.MoveMembers
                ],
            }
        ];
        
        // Dodaj uprawnienia dla ka≈ºdej znalezionej roli
        if (zweryfikowanyRole) {
            permissionOverwrites.push({
                id: zweryfikowanyRole.id,
                allow: [PermissionFlagsBits.ViewChannel, PermissionFlagsBits.Connect],
            });
        }
        
        if (moderatorRole) {
            permissionOverwrites.push({
                id: moderatorRole.id,
                allow: [PermissionFlagsBits.ViewChannel, PermissionFlagsBits.Connect],
            });
        }
        
        if (adminRole) {
            permissionOverwrites.push({
                id: adminRole.id,
                allow: [PermissionFlagsBits.ViewChannel, PermissionFlagsBits.Connect],
            });
        }
        
        if (bf6Role) {
            permissionOverwrites.push({
                id: bf6Role.id,
                allow: [PermissionFlagsBits.ViewChannel, PermissionFlagsBits.Connect],
            });
        }
        
        // Utw√≥rz nowy kana≈Ç g≈Çosowy
        const voiceChannel = await guild.channels.create({
            name: channelName,
            type: ChannelType.GuildVoice,
            parent: categoryId || null,
            userLimit: 5, // Domy≈õlny limit 5 u≈ºytkownik√≥w
            permissionOverwrites: permissionOverwrites
        });
        
        // Zapisz informacje o kanale
        client.createdChannels.set(member.id, voiceChannel.id);
        client.channelOwners.set(voiceChannel.id, member.id);
        
        // Przenie≈õ u≈ºytkownika do nowego kana≈Çu
        await member.voice.setChannel(voiceChannel.id);
        
        console.log(`‚úÖ Utworzono kana≈Ç g≈Çosowy: ${channelName} dla ${member.displayName}`);
        
    } catch (error) {
        console.error('‚ùå B≈ÇƒÖd podczas tworzenia kana≈Çu g≈Çosowego:', error);
    }
}

// Funkcja sprawdzajƒÖca i usuwajƒÖca pusty kana≈Ç
async function checkAndDeleteEmptyChannel(channel) {
    try {
        // Sprawd≈∫ czy kana≈Ç jest utworzony przez bota
        const ownerId = client.channelOwners.get(channel.id);
        if (!ownerId) return;
        
        // Sprawd≈∫ czy kana≈Ç jest pusty
        if (channel.members.size === 0) {
            // Usu≈Ñ kana≈Ç po 5 sekundach (daje czas na powr√≥t)
            setTimeout(async () => {
                try {
                    const updatedChannel = channel.guild.channels.cache.get(channel.id);
                    if (updatedChannel && updatedChannel.members.size === 0) {
                        await updatedChannel.delete('Kana≈Ç pusty - automatyczne usuniƒôcie');
                        
                        // Usu≈Ñ z pamiƒôci bota
                        client.createdChannels.delete(ownerId);
                        client.channelOwners.delete(channel.id);
                        
                        console.log(`üóëÔ∏è Usuniƒôto pusty kana≈Ç: ${channel.name}`);
                    }
                } catch (error) {
                    console.error('‚ùå B≈ÇƒÖd podczas usuwania kana≈Çu:', error);
                }
            }, 5000);
        }
    } catch (error) {
        console.error('‚ùå B≈ÇƒÖd podczas sprawdzania pustego kana≈Çu:', error);
    }
}

// Event: Obs≈Çuga komend slash
client.on('interactionCreate', async interaction => {
    if (!interaction.isChatInputCommand()) return;
    
    const command = client.commands.get(interaction.commandName);
    if (!command) return;
    
    try {
        await command.execute(interaction, client);
    } catch (error) {
        console.error('‚ùå B≈ÇƒÖd podczas wykonywania komendy:', error);
        const reply = {
            content: '‚ùå WystƒÖpi≈Ç b≈ÇƒÖd podczas wykonywania komendy.',
            ephemeral: true
        };
        
        if (interaction.replied || interaction.deferred) {
            await interaction.followUp(reply);
        } else {
            await interaction.reply(reply);
        }
    }
});

// Obs≈Çuga dodawania reakcji
client.on('messageReactionAdd', async (reaction, user) => {
    // Ignoruj reakcje bota
    if (user.bot) return;

    // Sprawd≈∫ czy reakcja jest czƒô≈õciowa (nie w cache)
    if (reaction.partial) {
        try {
            await reaction.fetch();
        } catch (error) {
            console.error('‚ùå B≈ÇƒÖd podczas pobierania reakcji:', error);
            return;
        }
    }

    await handleReactionRole(reaction, user, 'add');
});

// Obs≈Çuga usuwania reakcji
client.on('messageReactionRemove', async (reaction, user) => {
    // Ignoruj reakcje bota
    if (user.bot) return;

    // Sprawd≈∫ czy reakcja jest czƒô≈õciowa (nie w cache)
    if (reaction.partial) {
        try {
            await reaction.fetch();
        } catch (error) {
            console.error('‚ùå B≈ÇƒÖd podczas pobierania reakcji:', error);
            return;
        }
    }

    await handleReactionRole(reaction, user, 'remove');
});

// Funkcja obs≈ÇugujƒÖca reaction roles
async function handleReactionRole(reaction, user, action) {
    try {
        const messageId = reaction.message.id;
        const reactionConfig = client.reactionRoles.get(messageId);
        
        if (!reactionConfig) return; // Brak konfiguracji dla tej wiadomo≈õci

        // Sprawd≈∫ czy emoji siƒô zgadza
        const reactionEmoji = reaction.emoji.name || reaction.emoji.toString();
        if (reactionEmoji !== reactionConfig.emoji && reaction.emoji.toString() !== reactionConfig.emoji) {
            return; // Niepoprawne emoji
        }

        const guild = reaction.message.guild;
        const member = await guild.members.fetch(user.id);
        const role = guild.roles.cache.get(reactionConfig.roleId);

        if (!role) {
            console.error(`‚ùå Nie znaleziono roli o ID: ${reactionConfig.roleId}`);
            return;
        }

        if (action === 'add') {
            // Dodaj rolƒô
            if (!member.roles.cache.has(role.id)) {
                await member.roles.add(role);
                console.log(`‚úÖ Dodano rolƒô ${role.name} u≈ºytkownikowi ${user.tag}`);
            }
        } else if (action === 'remove') {
            // Usu≈Ñ rolƒô
            if (member.roles.cache.has(role.id)) {
                await member.roles.remove(role);
                console.log(`‚ûñ Usuniƒôto rolƒô ${role.name} u≈ºytkownikowi ${user.tag}`);
            }
        }

    } catch (error) {
        console.error('‚ùå B≈ÇƒÖd podczas obs≈Çugi reaction role:', error);
    }
}

// Obs≈Çuga wiadomo≈õci dla auto-moderacji
client.on('messageCreate', async (message) => {
    try {
        await processMessage(client, message);
    } catch (error) {
        console.error('‚ùå B≈ÇƒÖd w auto-moderacji:', error);
    }
});

// Event: Nowy u≈ºytkownik do≈ÇƒÖczy≈Ç do serwera
client.on('guildMemberAdd', async (member) => {
    try {
        await handleMemberJoin(member);
    } catch (error) {
        console.error('‚ùå B≈ÇƒÖd podczas obs≈Çugi do≈ÇƒÖczenia u≈ºytkownika:', error);
    }
});

// Event: U≈ºytkownik opu≈õci≈Ç serwer
client.on('guildMemberRemove', async (member) => {
    try {
        await handleMemberLeave(member);
    } catch (error) {
        console.error('‚ùå B≈ÇƒÖd podczas obs≈Çugi opuszczenia serwera:', error);
    }
});

// Event: Zmiana r√≥l u≈ºytkownika
client.on('guildMemberUpdate', async (oldMember, newMember) => {
    try {
        await handleMemberUpdate(oldMember, newMember);
    } catch (error) {
        console.error('‚ùå B≈ÇƒÖd podczas obs≈Çugi zmiany u≈ºytkownika:', error);
    }
});

// Event: Ban u≈ºytkownika
client.on('guildBanAdd', async (ban) => {
    try {
        await handleBanAdd(ban);
    } catch (error) {
        console.error('‚ùå B≈ÇƒÖd podczas obs≈Çugi bana:', error);
    }
});

// Event: Unban u≈ºytkownika
client.on('guildBanRemove', async (ban) => {
    try {
        await handleBanRemove(ban);
    } catch (error) {
        console.error('‚ùå B≈ÇƒÖd podczas obs≈Çugi unbana:', error);
    }
});

// Event: Usuniƒôcie wiadomo≈õci
client.on('messageDelete', async (message) => {
    try {
        if (!message.author || message.author.bot) return;
        await handleMessageDelete(message);
    } catch (error) {
        console.error('‚ùå B≈ÇƒÖd podczas obs≈Çugi usuniƒôcia wiadomo≈õci:', error);
    }
});

// Event: Edycja wiadomo≈õci
client.on('messageUpdate', async (oldMessage, newMessage) => {
    try {
        if (!oldMessage.author || oldMessage.author.bot) return;
        if (oldMessage.content === newMessage.content) return;
        await handleMessageUpdate(oldMessage, newMessage);
    } catch (error) {
        console.error('‚ùå B≈ÇƒÖd podczas obs≈Çugi edycji wiadomo≈õci:', error);
    }
});

// Funkcje rozszerzonego systemu logowania
async function handleMemberUpdate(oldMember, newMember) {
    const logChannel = newMember.guild.channels.cache.get(LOG_CHANNEL_ID);
    if (!logChannel) return;
    
    // Sprawd≈∫ zmiany r√≥l
    const oldRoles = oldMember.roles.cache;
    const newRoles = newMember.roles.cache;
    
    const addedRoles = newRoles.filter(role => !oldRoles.has(role.id));
    const removedRoles = oldRoles.filter(role => !newRoles.has(role.id));
    
    if (addedRoles.size > 0 || removedRoles.size > 0) {
        const embed = {
            color: 0x3498DB,
            title: 'üîÑ Zmiana r√≥l u≈ºytkownika',
            fields: [
                { name: 'U≈ºytkownik', value: `${newMember.user.tag} (${newMember.user.id})`, inline: true }
            ],
            thumbnail: { url: newMember.user.displayAvatarURL({ dynamic: true }) },
            timestamp: new Date().toISOString(),
            footer: { text: 'System Logowania' }
        };
        
        if (addedRoles.size > 0) {
            embed.fields.push({
                name: '‚ûï Dodane role',
                value: addedRoles.map(role => `<@&${role.id}>`).join(', '),
                inline: false
            });
        }
        
        if (removedRoles.size > 0) {
            embed.fields.push({
                name: '‚ûñ Usuniƒôte role',
                value: removedRoles.map(role => `<@&${role.id}>`).join(', '),
                inline: false
            });
        }
        
        await logChannel.send({ embeds: [embed] });
    }
    
    // Sprawd≈∫ zmianƒô nicku
    if (oldMember.nickname !== newMember.nickname) {
        const embed = {
            color: 0x9B59B6,
            title: 'üìù Zmiana nicku',
            fields: [
                { name: 'U≈ºytkownik', value: `${newMember.user.tag} (${newMember.user.id})`, inline: true },
                { name: 'Stary nick', value: oldMember.nickname || 'Brak', inline: true },
                { name: 'Nowy nick', value: newMember.nickname || 'Brak', inline: true }
            ],
            thumbnail: { url: newMember.user.displayAvatarURL({ dynamic: true }) },
            timestamp: new Date().toISOString(),
            footer: { text: 'System Logowania' }
        };
        
        await logChannel.send({ embeds: [embed] });
    }
}

async function handleBanAdd(ban) {
    const logChannel = ban.guild.channels.cache.get(LOG_CHANNEL_ID);
    if (!logChannel) return;
    
    const embed = {
        color: 0xE74C3C,
        title: 'üî® U≈ºytkownik zosta≈Ç zbanowany',
        fields: [
            { name: 'U≈ºytkownik', value: `${ban.user.tag} (${ban.user.id})`, inline: true },
            { name: 'Pow√≥d', value: ban.reason || 'Nie podano powodu', inline: true }
        ],
        thumbnail: { url: ban.user.displayAvatarURL({ dynamic: true }) },
        timestamp: new Date().toISOString(),
        footer: { text: 'System Logowania' }
    };
    
    await logChannel.send({ embeds: [embed] });
    console.log(`üî® ${ban.user.tag} zosta≈Ç zbanowany: ${ban.reason || 'Brak powodu'}`);
}

async function handleBanRemove(ban) {
    const logChannel = ban.guild.channels.cache.get(LOG_CHANNEL_ID);
    if (!logChannel) return;
    
    const embed = {
        color: 0x2ECC71,
        title: 'üîì U≈ºytkownik zosta≈Ç odbanowany',
        fields: [
            { name: 'U≈ºytkownik', value: `${ban.user.tag} (${ban.user.id})`, inline: true }
        ],
        thumbnail: { url: ban.user.displayAvatarURL({ dynamic: true }) },
        timestamp: new Date().toISOString(),
        footer: { text: 'System Logowania' }
    };
    
    await logChannel.send({ embeds: [embed] });
    console.log(`üîì ${ban.user.tag} zosta≈Ç odbanowany`);
}

async function handleMessageDelete(message) {
    const logChannel = message.guild.channels.cache.get(LOG_CHANNEL_ID);
    if (!logChannel) return;
    
    // Nie loguj wiadomo≈õci usuniƒôtych przez auto-moderacjƒô
    if (message.content && message.content.length > 0) {
        const embed = {
            color: 0xE67E22,
            title: 'üóëÔ∏è Wiadomo≈õƒá zosta≈Ça usuniƒôta',
            fields: [
                { name: 'Autor', value: `${message.author.tag} (${message.author.id})`, inline: true },
                { name: 'Kana≈Ç', value: `${message.channel}`, inline: true },
                { name: 'Tre≈õƒá', value: message.content.substring(0, 1000) + (message.content.length > 1000 ? '...' : ''), inline: false }
            ],
            thumbnail: { url: message.author.displayAvatarURL({ dynamic: true }) },
            timestamp: new Date().toISOString(),
            footer: { text: 'System Logowania' }
        };
        
        await logChannel.send({ embeds: [embed] });
    }
}

async function handleMessageUpdate(oldMessage, newMessage) {
    const logChannel = newMessage.guild.channels.cache.get(LOG_CHANNEL_ID);
    if (!logChannel) return;
    
    const embed = {
        color: 0xF39C12,
        title: '‚úèÔ∏è Wiadomo≈õƒá zosta≈Ça edytowana',
        fields: [
            { name: 'Autor', value: `${newMessage.author.tag} (${newMessage.author.id})`, inline: true },
            { name: 'Kana≈Ç', value: `${newMessage.channel}`, inline: true },
            { name: 'Przed', value: oldMessage.content.substring(0, 500) + (oldMessage.content.length > 500 ? '...' : ''), inline: false },
            { name: 'Po', value: newMessage.content.substring(0, 500) + (newMessage.content.length > 500 ? '...' : ''), inline: false },
            { name: 'Link', value: `[Przejd≈∫ do wiadomo≈õci](${newMessage.url})`, inline: true }
        ],
        thumbnail: { url: newMessage.author.displayAvatarURL({ dynamic: true }) },
        timestamp: new Date().toISOString(),
        footer: { text: 'System Logowania' }
    };
    
    await logChannel.send({ embeds: [embed] });
}

// Funkcje Welcome/Leave System
async function handleMemberJoin(member) {
    const welcomeChannel = member.guild.channels.cache.get(WELCOME_CHANNEL_ID);
    const logChannel = member.guild.channels.cache.get(LOG_CHANNEL_ID);
    
    if (welcomeChannel) {
        const welcomeEmbed = {
            color: 0x00FF00,
            title: 'üëã Witamy na serwerze!',
            description: `Witaj ${member.user}! Mi≈Ço Ciƒô widzieƒá na naszym serwerze **${member.guild.name}**!`,
            fields: [
                { name: 'üìã Przeczytaj regulamin', value: 'Zapoznaj siƒô z zasadami serwera', inline: true },
                { name: 'üéÆ Baw siƒô dobrze!', value: '≈ªyczymy mi≈Çej zabawy!', inline: true }
            ],
            thumbnail: { url: member.user.displayAvatarURL({ dynamic: true }) },
            timestamp: new Date().toISOString(),
            footer: { text: `U≈ºytkownik #${member.guild.memberCount}` }
        };
        
        await welcomeChannel.send({ embeds: [welcomeEmbed] });
    }
    
    // Log do kana≈Çu moderacji
    if (logChannel) {
        const logEmbed = {
            color: 0x00FF00,
            title: 'üì• U≈ºytkownik do≈ÇƒÖczy≈Ç',
            fields: [
                { name: 'U≈ºytkownik', value: `${member.user.tag} (${member.user.id})`, inline: true },
                { name: 'Konto utworzone', value: `<t:${Math.floor(member.user.createdTimestamp / 1000)}:R>`, inline: true },
                { name: 'Cz≈Çonek #', value: `${member.guild.memberCount}`, inline: true }
            ],
            thumbnail: { url: member.user.displayAvatarURL({ dynamic: true }) },
            timestamp: new Date().toISOString(),
            footer: { text: 'System Welcome/Leave' }
        };
        
        await logChannel.send({ embeds: [logEmbed] });
    }
    
    console.log(`üëã ${member.user.tag} do≈ÇƒÖczy≈Ç do serwera ${member.guild.name}`);
}

async function handleMemberLeave(member) {
    const welcomeChannel = member.guild.channels.cache.get(WELCOME_CHANNEL_ID);
    const logChannel = member.guild.channels.cache.get(LOG_CHANNEL_ID);
    
    if (welcomeChannel) {
        const leaveEmbed = {
            color: 0xFF6B6B,
            title: 'üëã ≈ªegnamy u≈ºytkownika',
            description: `**${member.user.tag}** opu≈õci≈Ç serwer. ≈ªegnamy!`,
            thumbnail: { url: member.user.displayAvatarURL({ dynamic: true }) },
            timestamp: new Date().toISOString(),
            footer: { text: `Pozosta≈Ço ${member.guild.memberCount} cz≈Çonk√≥w` }
        };
        
        await welcomeChannel.send({ embeds: [leaveEmbed] });
    }
    
    // Log do kana≈Çu moderacji
    if (logChannel) {
        const joinedAt = member.joinedAt ? `<t:${Math.floor(member.joinedTimestamp / 1000)}:R>` : 'Nieznane';
        
        const logEmbed = {
            color: 0xFF6B6B,
            title: 'üì§ U≈ºytkownik opu≈õci≈Ç serwer',
            fields: [
                { name: 'U≈ºytkownik', value: `${member.user.tag} (${member.user.id})`, inline: true },
                { name: 'Do≈ÇƒÖczy≈Ç', value: joinedAt, inline: true },
                { name: 'Pozosta≈Ço cz≈Çonk√≥w', value: `${member.guild.memberCount}`, inline: true }
            ],
            thumbnail: { url: member.user.displayAvatarURL({ dynamic: true }) },
            timestamp: new Date().toISOString(),
            footer: { text: 'System Welcome/Leave' }
        };
        
        await logChannel.send({ embeds: [logEmbed] });
    }
    
    console.log(`üëã ${member.user.tag} opu≈õci≈Ç serwer ${member.guild.name}`);
}

// Funkcja do wysy≈Çania log√≥w do kana≈Çu moderacji
async function sendLogToModerationChannel(guild, embed) {
    try {
        const logChannel = guild.channels.cache.get(LOG_CHANNEL_ID);
        if (logChannel) {
            await logChannel.send({ embeds: [embed] });
        }
    } catch (error) {
        console.error('B≈ÇƒÖd podczas wysy≈Çania loga do kana≈Çu moderacji:', error);
    }
}

// Funkcje obs≈Çugi news√≥w Battlefield 6
async function checkBF6News() {
    try {
        const channel = client.channels.cache.get(BF6_NEWS_CHANNEL_ID);
        if (!channel) {
            console.error(`‚ùå Nie znaleziono kana≈Çu news√≥w BF6 o ID: ${BF6_NEWS_CHANNEL_ID}`);
            console.log(`üìã Dostƒôpne kana≈Çy: ${client.channels.cache.map(ch => `${ch.name} (${ch.id})`).join(', ')}`);
            return;
        }

        console.log(`üîç Sprawdzanie news√≥w Battlefield 6... Kana≈Ç: ${channel.name}`);
        
        // Prze≈Çaduj wys≈Çane newsy z pliku przed ka≈ºdym sprawdzeniem
        loadSentNews();
        
        for (const feedUrl of RSS_FEEDS) {
            try {
                const feed = await parser.parseURL(feedUrl);
                
                // Filtrowanie artyku≈Ç√≥w zwiƒÖzanych TYLKO z Battlefield 6
                const battlefieldItems = feed.items.filter(item => {
                    const title = item.title.toLowerCase();
                    const content = (item.contentSnippet || item.content || '').toLowerCase();
                    const fullText = `${title} ${content}`;
                    
                    // Sprawdzanie czy artyku≈Ç dotyczy Battlefield 6
                    const bf6Keywords = [
                        'battlefield 6', 'bf6', 'battlefield vi'
                    ];
                    
                    // Wykluczanie starszych czƒô≈õci Battlefield
                    const excludeKeywords = [
                        'battlefield 1', 'battlefield v', 'battlefield 4',
                        'battlefield 3', 'battlefield bad company',
                        'battlefield hardline', 'battlefield portal',
                        'battlefield 2042'
                    ];
                    
                    // Sprawd≈∫ czy zawiera s≈Çowa kluczowe BF6
                    const hasBF6Keywords = bf6Keywords.some(keyword => fullText.includes(keyword));
                    
                    // Sprawd≈∫ czy nie zawiera wykluczonych s≈Ç√≥w
                    const hasExcludedKeywords = excludeKeywords.some(keyword => fullText.includes(keyword));
                    
                    return hasBF6Keywords && !hasExcludedKeywords;
                });

                // Wysy≈Çanie najnowszego artyku≈Çu (tylko 1)
                if (battlefieldItems.length > 0) {
                    const latestItem = battlefieldItems[0]; // Tylko najnowszy
                    const newsHash = generateNewsHash(latestItem);
                    
                    if (!client.lastNewsItems.has(newsHash)) {
                        await sendBF6NewsToChannel(channel, latestItem, feedUrl);
                        client.lastNewsItems.add(newsHash);
                        
                        // Zapisanie do pliku po ka≈ºdym nowym newsie
                        saveSentNews();
                        
                        // Ograniczenie rozmiaru Set (ostatnie 200 news√≥w)
                        if (client.lastNewsItems.size > 200) {
                            const itemsArray = Array.from(client.lastNewsItems);
                            client.lastNewsItems = new Set(itemsArray.slice(-200));
                            saveSentNews(); // Zapisz po oczyszczeniu
                        }
                        
                        console.log(`‚úÖ Wys≈Çano najnowszy news BF6: ${latestItem.title}`);
                    } else {
                        console.log(`‚è≠Ô∏è Najnowszy news ju≈º istnieje: ${latestItem.title}`);
                    }
                }
                
            } catch (feedError) {
                console.error(`‚ùå B≈ÇƒÖd podczas parsowania feed ${feedUrl}:`, feedError.message);
            }
        }
        
    } catch (error) {
        console.error('‚ùå B≈ÇƒÖd podczas sprawdzania news√≥w BF6:', error);
    }
}

async function sendBF6NewsToChannel(channel, item, source) {
    try {
        const embed = {
            color: 0xFF6B35, // Pomara≈Ñczowy kolor Battlefield
            title: item.title,
            url: item.link,
            description: (item.contentSnippet || item.content || 'Brak opisu').substring(0, 300) + '...',
            fields: [
                {
                    name: 'üîó ≈πr√≥d≈Ço',
                    value: getSourceName(source),
                    inline: true
                },
                {
                    name: 'üìÖ Data',
                    value: item.pubDate ? new Date(item.pubDate).toLocaleDateString('pl-PL') : 'Nieznana',
                    inline: true
                }
            ],
            footer: {
                text: 'üéÆ Battlefield 6 News Bot'
            },
            timestamp: new Date().toISOString()
        };

        await channel.send({ embeds: [embed] });
        console.log(`üì∞ Wys≈Çano news BF6: ${item.title}`);
        
    } catch (error) {
        console.error('‚ùå B≈ÇƒÖd podczas wysy≈Çania newsa:', error);
    }
}

function getSourceName(feedUrl) {
    if (feedUrl.includes('gamespot')) return 'GameSpot';
    if (feedUrl.includes('ign')) return 'IGN';
    if (feedUrl.includes('polygon')) return 'Polygon';
    if (feedUrl.includes('gameranx')) return 'GameRanx';
    if (feedUrl.includes('insider-gaming')) return 'Insider Gaming';
    return 'Nieznane ≈∫r√≥d≈Ço';
}

function startBF6NewsScheduler() {
    // Sprawdzanie co 30 minut
    cron.schedule('*/30 * * * *', async () => {
        console.log('‚è∞ Automatyczne sprawdzanie news√≥w BF6...');
        await checkBF6News();
    });
    
    console.log('‚úÖ Harmonogram news√≥w BF6 uruchomiony (co 30 minut)');
}

// Funkcja rejestrujƒÖca komendy slash
async function registerSlashCommands() {
    try {
        const rest = new REST({ version: '10' }).setToken(process.env.DISCORD_TOKEN);
        
        const commandData = commands.map(command => command.data.toJSON());
        
        console.log('üîÑ Rejestrowanie komend slash...');
        
        if (process.env.GUILD_ID) {
            // Rejestracja dla konkretnego serwera (szybsza)
            await rest.put(
                Routes.applicationGuildCommands(client.user.id, process.env.GUILD_ID),
                { body: commandData }
            );
            console.log('‚úÖ Komendy slash zarejestrowane dla serwera');
        } else {
            // Rejestracja globalna (mo≈ºe potrwaƒá do godziny)
            await rest.put(
                Routes.applicationCommands(client.user.id),
                { body: commandData }
            );
            console.log('‚úÖ Komendy slash zarejestrowane globalnie');
        }
    } catch (error) {
        console.error('‚ùå B≈ÇƒÖd podczas rejestrowania komend:', error);
    }
}

// Obs≈Çuga b≈Çƒôd√≥w
client.on('error', error => {
    console.error('‚ùå B≈ÇƒÖd klienta Discord:', error);
});

process.on('unhandledRejection', error => {
    console.error('‚ùå Nieobs≈Çu≈ºone odrzucenie:', error);
});

// Logowanie bota
client.login(process.env.DISCORD_TOKEN);

module.exports = client;