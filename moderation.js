const { SlashCommandBuilder, PermissionFlagsBits, EmbedBuilder } = require('discord.js');
const { addModerationEntry, loadModerationHistory } = require('./auto-moderation');

// ID kana≈Çu do logowania moderacji
const LOG_CHANNEL_ID = '1412925469338107945';

// Funkcja do wysy≈Çania log√≥w do kana≈Çu
async function sendLogToChannel(client, embed) {
    try {
        const logChannel = await client.channels.fetch(LOG_CHANNEL_ID);
        if (logChannel) {
            await logChannel.send({ embeds: [embed] });
        }
    } catch (error) {
        console.error('B≈ÇƒÖd podczas wysy≈Çania loga do kana≈Çu:', error);
    }
}

// Komenda /warn - ostrze≈ºenie u≈ºytkownika
const warnCommand = {
    data: new SlashCommandBuilder()
        .setName('warn')
        .setDescription('Ostrze≈º u≈ºytkownika')
        .addUserOption(option =>
            option.setName('u≈ºytkownik')
                .setDescription('U≈ºytkownik do ostrze≈ºenia')
                .setRequired(true))
        .addStringOption(option =>
            option.setName('pow√≥d')
                .setDescription('Pow√≥d ostrze≈ºenia')
                .setRequired(true))
        .setDefaultMemberPermissions(PermissionFlagsBits.ModerateMembers),
    
    async execute(interaction) {
        const targetUser = interaction.options.getUser('u≈ºytkownik');
        const reason = interaction.options.getString('pow√≥d');
        const moderator = interaction.user;
        
        // Sprawdzenie czy interakcja ju≈º zosta≈Ça obs≈Çu≈ºona
        let replied = false;
        
        try {
            // Sprawdzenie czy u≈ºytkownik jest na serwerze
            const targetMember = await interaction.guild.members.fetch(targetUser.id).catch(() => null);
            if (!targetMember) {
                await interaction.reply({
                    content: '‚ùå Nie znaleziono u≈ºytkownika na tym serwerze.',
                    ephemeral: true
                });
                return;
            }
            
            // Sprawdzenie hierarchii r√≥l
            if (targetMember.roles.highest.position >= interaction.member.roles.highest.position) {
                await interaction.reply({
                    content: '‚ùå Nie mo≈ºesz ostrzec u≈ºytkownika z wy≈ºszƒÖ lub r√≥wnƒÖ rolƒÖ.',
                    ephemeral: true
                });
                return;
            }
            
            // Dodanie wpisu do historii moderacji
            addModerationEntry(targetUser.id, 'warn', reason, moderator.tag);
            
            // Utworzenie embeda z ostrze≈ºeniem
            const warnEmbed = new EmbedBuilder()
                .setColor(0xFFFF00)
                .setTitle('‚ö†Ô∏è Ostrze≈ºenie')
                .setDescription(`${targetUser} otrzyma≈Ç ostrze≈ºenie od ${moderator}`)
                .addFields(
                    { name: 'Pow√≥d', value: reason, inline: false },
                    { name: 'Moderator', value: moderator.tag, inline: true },
                    { name: 'Data', value: new Date().toLocaleString('pl-PL'), inline: true }
                )
                .setTimestamp();
            
            // Wys≈Çanie ostrze≈ºenia na kana≈Ç
            await interaction.reply({ embeds: [warnEmbed] });
            replied = true;
            
            // Wys≈Çanie loga do kana≈Çu moderacji
            await sendLogToChannel(interaction.client, warnEmbed);
            
            // Pr√≥ba wys≈Çania DM do u≈ºytkownika
            try {
                const dmEmbed = new EmbedBuilder()
                    .setColor(0xFFFF00)
                    .setTitle('‚ö†Ô∏è Otrzyma≈Çe≈õ ostrze≈ºenie')
                    .setDescription(`Zosta≈Çe≈õ ostrze≈ºony na serwerze **${interaction.guild.name}**`)
                    .addFields(
                        { name: 'Pow√≥d', value: reason, inline: false },
                        { name: 'Moderator', value: moderator.tag, inline: true }
                    )
                    .setTimestamp();
                
                await targetUser.send({ embeds: [dmEmbed] });
            } catch (dmError) {
                console.log(`Nie uda≈Ço siƒô wys≈Çaƒá DM do ${targetUser.tag}:`, dmError.message);
            }
            
            console.log(`‚ö†Ô∏è ${moderator.tag} ostrzeg≈Ç ${targetUser.tag}: ${reason}`);
            
        } catch (error) {
            console.error('B≈ÇƒÖd podczas ostrzegania:', error);
            if (!replied && !interaction.replied) {
                try {
                    await interaction.reply({
                        content: '‚ùå WystƒÖpi≈Ç b≈ÇƒÖd podczas ostrzegania u≈ºytkownika.',
                        ephemeral: true
                    });
                } catch (replyError) {
                    console.error('Nie uda≈Ço siƒô wys≈Çaƒá odpowiedzi o b≈Çƒôdzie:', replyError);
                }
            }
        }
    }
};

// Komenda /kick - wyrzucenie u≈ºytkownika
const kickCommand = {
    data: new SlashCommandBuilder()
        .setName('kick')
        .setDescription('Wyrzuƒá u≈ºytkownika z serwera')
        .addUserOption(option =>
            option.setName('u≈ºytkownik')
                .setDescription('U≈ºytkownik do wyrzucenia')
                .setRequired(true))
        .addStringOption(option =>
            option.setName('pow√≥d')
                .setDescription('Pow√≥d wyrzucenia')
                .setRequired(true))
        .setDefaultMemberPermissions(PermissionFlagsBits.KickMembers),
    
    async execute(interaction) {
        const targetUser = interaction.options.getUser('u≈ºytkownik');
        const reason = interaction.options.getString('pow√≥d');
        const moderator = interaction.user;
        
        // Sprawdzenie czy interakcja ju≈º zosta≈Ça obs≈Çu≈ºona
        let replied = false;
        
        try {
            // Sprawdzenie czy u≈ºytkownik jest na serwerze
            const targetMember = await interaction.guild.members.fetch(targetUser.id).catch(() => null);
            if (!targetMember) {
                await interaction.reply({
                    content: '‚ùå Nie znaleziono u≈ºytkownika na tym serwerze.',
                    ephemeral: true
                });
                return;
            }
            
            // Sprawdzenie czy u≈ºytkownik mo≈ºe byƒá wyrzucony
            if (!targetMember.kickable) {
                await interaction.reply({
                    content: '‚ùå Nie mogƒô wyrzuciƒá tego u≈ºytkownika (prawdopodobnie ma wy≈ºszƒÖ rolƒô ni≈º bot).',
                    ephemeral: true
                });
                return;
            }
            
            // Sprawdzenie hierarchii r√≥l
            if (targetMember.roles.highest.position >= interaction.member.roles.highest.position) {
                await interaction.reply({
                    content: '‚ùå Nie mo≈ºesz wyrzuciƒá u≈ºytkownika z wy≈ºszƒÖ lub r√≥wnƒÖ rolƒÖ.',
                    ephemeral: true
                });
                return;
            }
            
            // Pr√≥ba wys≈Çania DM przed wyrzuceniem
            try {
                const dmEmbed = new EmbedBuilder()
                    .setColor(0xFF4500)
                    .setTitle('üë¢ Zosta≈Çe≈õ wyrzucony')
                    .setDescription(`Zosta≈Çe≈õ wyrzucony z serwera **${interaction.guild.name}**`)
                    .addFields(
                        { name: 'Pow√≥d', value: reason, inline: false },
                        { name: 'Moderator', value: moderator.tag, inline: true }
                    )
                    .setTimestamp();
                
                await targetUser.send({ embeds: [dmEmbed] });
            } catch (dmError) {
                console.log(`Nie uda≈Ço siƒô wys≈Çaƒá DM do ${targetUser.tag}:`, dmError.message);
            }
            
            // Wyrzucenie u≈ºytkownika
            await targetMember.kick(reason);
            
            // Dodanie wpisu do historii moderacji
            addModerationEntry(targetUser.id, 'kick', reason, moderator.tag);
            
            // Utworzenie embeda z informacjƒÖ o wyrzuceniu
            const kickEmbed = new EmbedBuilder()
                .setColor(0xFF4500)
                .setTitle('üë¢ Wyrzucenie')
                .setDescription(`${targetUser.tag} zosta≈Ç wyrzucony z serwera`)
                .addFields(
                    { name: 'Pow√≥d', value: reason, inline: false },
                    { name: 'Moderator', value: moderator.tag, inline: true },
                    { name: 'Data', value: new Date().toLocaleString('pl-PL'), inline: true }
                )
                .setTimestamp();
            
            await interaction.reply({ embeds: [kickEmbed] });
            replied = true;
            
            // Wys≈Çanie loga do kana≈Çu moderacji
            await sendLogToChannel(interaction.client, kickEmbed);
            
            console.log(`üë¢ ${moderator.tag} wyrzuci≈Ç ${targetUser.tag}: ${reason}`);
            
        } catch (error) {
            console.error('B≈ÇƒÖd podczas wyrzucania:', error);
            if (!replied && !interaction.replied) {
                try {
                    await interaction.reply({
                        content: '‚ùå WystƒÖpi≈Ç b≈ÇƒÖd podczas wyrzucania u≈ºytkownika.',
                        ephemeral: true
                    });
                } catch (replyError) {
                    console.error('Nie uda≈Ço siƒô wys≈Çaƒá odpowiedzi o b≈Çƒôdzie:', replyError);
                }
            }
        }
    }
};

// Komenda /ban - zbanowanie u≈ºytkownika
const banCommand = {
    data: new SlashCommandBuilder()
        .setName('ban')
        .setDescription('Zbanuj u≈ºytkownika')
        .addUserOption(option =>
            option.setName('u≈ºytkownik')
                .setDescription('U≈ºytkownik do zbanowania')
                .setRequired(true))
        .addStringOption(option =>
            option.setName('pow√≥d')
                .setDescription('Pow√≥d bana')
                .setRequired(true))
        .addIntegerOption(option =>
            option.setName('dni_wiadomo≈õci')
                .setDescription('Ile dni wiadomo≈õci usunƒÖƒá (0-7, domy≈õlnie 1)')
                .setMinValue(0)
                .setMaxValue(7))
        .setDefaultMemberPermissions(PermissionFlagsBits.BanMembers),
    
    async execute(interaction) {
        const targetUser = interaction.options.getUser('u≈ºytkownik');
        const reason = interaction.options.getString('pow√≥d');
        const deleteMessageDays = interaction.options.getInteger('dni_wiadomo≈õci') || 1;
        const moderator = interaction.user;
        
        // Sprawdzenie czy interakcja ju≈º zosta≈Ça obs≈Çu≈ºona
        let replied = false;
        
        try {
            // Sprawdzenie czy u≈ºytkownik jest na serwerze
            const targetMember = await interaction.guild.members.fetch(targetUser.id).catch(() => null);
            
            if (targetMember) {
                // Sprawdzenie czy u≈ºytkownik mo≈ºe byƒá zbanowany
                if (!targetMember.bannable) {
                    await interaction.reply({
                        content: '‚ùå Nie mogƒô zbanowaƒá tego u≈ºytkownika (prawdopodobnie ma wy≈ºszƒÖ rolƒô ni≈º bot).',
                        ephemeral: true
                    });
                    return;
                }
                
                // Sprawdzenie hierarchii r√≥l
                if (targetMember.roles.highest.position >= interaction.member.roles.highest.position) {
                    await interaction.reply({
                        content: '‚ùå Nie mo≈ºesz zbanowaƒá u≈ºytkownika z wy≈ºszƒÖ lub r√≥wnƒÖ rolƒÖ.',
                        ephemeral: true
                    });
                    return;
                }
                
                // Pr√≥ba wys≈Çania DM przed banem
                try {
                    const dmEmbed = new EmbedBuilder()
                        .setColor(0xFF0000)
                        .setTitle('üî® Zosta≈Çe≈õ zbanowany')
                        .setDescription(`Zosta≈Çe≈õ zbanowany na serwerze **${interaction.guild.name}**`)
                        .addFields(
                            { name: 'Pow√≥d', value: reason, inline: false },
                            { name: 'Moderator', value: moderator.tag, inline: true }
                        )
                        .setTimestamp();
                    
                    await targetUser.send({ embeds: [dmEmbed] });
                } catch (dmError) {
                    console.log(`Nie uda≈Ço siƒô wys≈Çaƒá DM do ${targetUser.tag}:`, dmError.message);
                }
            }
            
            // Zbanowanie u≈ºytkownika
            await interaction.guild.members.ban(targetUser, {
                reason: reason,
                deleteMessageDays: deleteMessageDays
            });
            
            // Dodanie wpisu do historii moderacji
            addModerationEntry(targetUser.id, 'ban', reason, moderator.tag);
            
            // Utworzenie embeda z informacjƒÖ o banie
            const banEmbed = new EmbedBuilder()
                .setColor(0xFF0000)
                .setTitle('üî® Ban')
                .setDescription(`${targetUser.tag} zosta≈Ç zbanowany`)
                .addFields(
                    { name: 'Pow√≥d', value: reason, inline: false },
                    { name: 'Moderator', value: moderator.tag, inline: true },
                    { name: 'Usuniƒôte wiadomo≈õci', value: `${deleteMessageDays} dni`, inline: true },
                    { name: 'Data', value: new Date().toLocaleString('pl-PL'), inline: true }
                )
                .setTimestamp();
            
            await interaction.reply({ embeds: [banEmbed] });
            replied = true;
            
            // Wys≈Çanie loga do kana≈Çu moderacji
            await sendLogToChannel(interaction.client, banEmbed);
            
            console.log(`üî® ${moderator.tag} zbanowa≈Ç ${targetUser.tag}: ${reason}`);
            
        } catch (error) {
            console.error('B≈ÇƒÖd podczas banowania:', error);
            if (!replied && !interaction.replied) {
                try {
                    await interaction.reply({
                        content: '‚ùå WystƒÖpi≈Ç b≈ÇƒÖd podczas banowania u≈ºytkownika.',
                        ephemeral: true
                    });
                } catch (replyError) {
                    console.error('Nie uda≈Ço siƒô wys≈Çaƒá odpowiedzi o b≈Çƒôdzie:', replyError);
                }
            }
        }
    }
};

// Komenda /modlogs - wy≈õwietlenie historii moderacji
const modlogsCommand = {
    data: new SlashCommandBuilder()
        .setName('modlogs')
        .setDescription('Wy≈õwietl historiƒô moderacji u≈ºytkownika')
        .addUserOption(option =>
            option.setName('u≈ºytkownik')
                .setDescription('U≈ºytkownik do sprawdzenia (opcjonalnie)')
                .setRequired(false))
        .addIntegerOption(option =>
            option.setName('limit')
                .setDescription('Liczba ostatnich wpis√≥w (domy≈õlnie 10)')
                .setMinValue(1)
                .setMaxValue(25))
        .setDefaultMemberPermissions(PermissionFlagsBits.ModerateMembers),
    
    async execute(interaction) {
        const targetUser = interaction.options.getUser('u≈ºytkownik');
        const limit = interaction.options.getInteger('limit') || 10;
        
        try {
            const history = loadModerationHistory();
            let allEntries = [];
            
            // Konwersja nowego formatu (obiekt) do tablicy
            if (typeof history === 'object' && !Array.isArray(history)) {
                // Nowy format - obiekt z kluczami u≈ºytkownik√≥w
                for (const [userId, userEntries] of Object.entries(history)) {
                    if (Array.isArray(userEntries)) {
                        userEntries.forEach(entry => {
                            allEntries.push({
                                ...entry,
                                userId: userId,
                                action: entry.type || entry.action // Obs≈Çuga obu format√≥w
                            });
                        });
                    }
                }
            } else if (Array.isArray(history)) {
                // Stary format - tablica
                allEntries = history;
            }
            
            let filteredHistory = allEntries;
            if (targetUser) {
                filteredHistory = allEntries.filter(entry => entry.userId === targetUser.id);
            }
            
            // Sortowanie od najnowszych
            filteredHistory.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            
            // Ograniczenie do limitu
            const limitedHistory = filteredHistory.slice(0, limit);
            
            if (limitedHistory.length === 0) {
                const noLogsMessage = targetUser 
                    ? `Brak wpis√≥w moderacyjnych dla u≈ºytkownika ${targetUser.tag}.`
                    : 'Brak wpis√≥w moderacyjnych.';
                
                return await interaction.reply({
                    content: noLogsMessage,
                    ephemeral: true
                });
            }
            
            const embed = new EmbedBuilder()
                .setColor(0x0099FF)
                .setTitle('üìã Historia Moderacji')
                .setDescription(targetUser ? `Historia dla u≈ºytkownika: ${targetUser.tag}` : 'Ostatnie akcje moderacyjne')
                .setTimestamp();
            
            // Dodanie wpis√≥w do embeda
            limitedHistory.forEach((entry, index) => {
                const date = new Date(entry.timestamp).toLocaleString('pl-PL');
                const action = entry.action || entry.type || 'unknown';
                const actionEmoji = {
                    'warn': '‚ö†Ô∏è',
                    'timeout': 'üîá',
                    'kick': 'üë¢',
                    'ban': 'üî®'
                }[action] || 'üìù';
                
                embed.addFields({
                    name: `${actionEmoji} ${action.toUpperCase()} #${index + 1}`,
                    value: `**U≈ºytkownik:** <@${entry.userId}>\n**Pow√≥d:** ${entry.reason}\n**Moderator:** ${entry.moderator}\n**Data:** ${date}`,
                    inline: false
                });
            });
            
            await interaction.reply({ embeds: [embed], ephemeral: true });
            
        } catch (error) {
            console.error('B≈ÇƒÖd podczas pobierania historii moderacji:', error);
            await interaction.reply({
                content: '‚ùå WystƒÖpi≈Ç b≈ÇƒÖd podczas pobierania historii moderacji.',
                ephemeral: true
            });
        }
    }
};

module.exports = {
    commands: [warnCommand, kickCommand, banCommand, modlogsCommand]
};